#  Copyright (c) 2021 KTH Royal Institute of Technology
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from sqlalchemy import create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm.exc import FlushError
from twisted.trial import unittest

from exprec.models import *


# noinspection PyTypeChecker
class TestDBModels(unittest.TestCase):
    def setUp(self) -> None:
        # set up an in-memory database connection
        engine = create_engine('sqlite:///:memory:', echo=True)
        Base.metadata.create_all(engine)
        self._session = sessionmaker(bind=engine)()

    def tearDown(self) -> None:
        self._session.close()

    def test_experiment_instance(self) -> ExperimentInstance:
        # create an experiment instance
        experiment = ExperimentInstance()

        self._session.add(experiment)
        self._session.commit()

        # check that ID has been autogenerated as is valid
        self.assertIsNotNone(experiment.id)
        self.assertIsInstance(experiment.id, uuid.UUID)

        # check that metadata and variable collections are empty
        self.assertEqual(len(experiment.variables), 0)
        self.assertEqual(len(experiment.experiment_metadata), 0)

        return experiment

    def test_experiment_metadata(self) -> None:
        # try to create metadata without a valid experiment id
        # for this to fail as expected, PRAGMA foreign_keys = ON needs to be
        # set: https://stackoverflow.com/a/31797403/5035798
        with self.assertRaises(IntegrityError):
            metadata = ExperimentMetadata(
                instance_id=uuid.uuid4(),
                label='invalid',
                value='metadata'
            )

            self._session.add(metadata)
            self._session.commit()

        self._session.rollback()

        # create an Experiment instance and attach some metadata to it
        instance = self.test_experiment_instance()
        metadata = ExperimentMetadata(
            instance_id=instance.id,
            label='valid',
            value='metadata!'
        )

        self._session.add(metadata)
        self._session.commit()

    def test_variable(self) -> InstanceVariable:
        # again, try to create a variable without a valid instance
        with self.assertRaises(IntegrityError):
            variable = InstanceVariable(
                name='invalid_variable',
                instance_id=uuid.uuid4(),
            )

            self._session.add(variable)
            self._session.commit()
        self._session.rollback()

        # create an instance, then a variable
        varname = 'valid_variable'
        instance = self.test_experiment_instance()
        variable = InstanceVariable(
            name=varname,
            instance_id=instance.id,
        )

        self._session.add(variable)
        self._session.commit()

        # verify we can't create duplicate variables for the same instance
        with self.assertRaises(IntegrityError):
            variable = InstanceVariable(
                name=varname,
                instance_id=instance.id
            )

            self._session.add(variable)
            self._session.commit()
        self._session.rollback()

        # verify we can create duplicate variables for different instances
        instance2 = self.test_experiment_instance()
        variable2 = InstanceVariable(
            name=varname,
            instance_id=instance2.id
        )

        self._session.add(variable2)
        self._session.commit()

        # verify we can create more than one variable per instance
        variable3 = InstanceVariable(
            name='valid_variable2',
            instance_id=instance.id
        )
        self._session.add(variable3)
        self._session.commit()

        self.assertEqual(len(instance.variables), 2)

        return variable3

    def test_record(self):
        # verify we can't create records for invalid variables
        with self.assertRaises(IntegrityError):
            record = VariableRecord(
                variable_id=uuid.uuid4(),
                timestamp=datetime.datetime.now(),
                value=666
            )

            self._session.add(record)
            self._session.commit()
        self._session.rollback()

        # create a valid record
        variable = self.test_variable()
        timestamp = datetime.datetime.now()
        record = VariableRecord(
            variable_id=variable.id,
            timestamp=timestamp,
            value=666
        )

        self._session.add(record)
        self._session.commit()

        # verify we can't create two records with the same timestamp
        with self.assertRaises(FlushError):
            record2 = VariableRecord(
                variable_id=variable.id,
                timestamp=timestamp,
                value=1337
            )

            self._session.add(record2)
            self._session.commit()
        self._session.rollback()

        # but records with different timestamps are fine
        record = VariableRecord(
            variable_id=variable.id,
            timestamp=datetime.datetime.now(),
            value=666
        )

        self._session.add(record)
        self._session.commit()
